import{J as e}from"./Dice-CiopnclC.js";var t=Object.defineProperty,n=(e,n,r)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,r=(e,t,r)=>(n(e,typeof t==`symbol`?t:t+``,r),r),i=(e,t,n)=>{if(!t.has(e))throw TypeError(`Cannot `+n)},a=(e,t,n)=>(i(e,t,`read from private field`),n?n.call(e):t.get(e)),o=(e,t,n)=>{if(t.has(e))throw TypeError(`Cannot add the same private member more than once`);t instanceof WeakSet?t.add(e):t.set(e,n)},s=(e,t,n,r)=>(i(e,t,`write to private field`),r?r.call(e,n):t.set(e,n),n),c=(e,t,n,r)=>({set _(r){s(e,t,r,n)},get _(){return a(e,t,r)}}),l,u,d,f,p,m,h=class{constructor(e){r(this,`config`),o(this,l,void 0),r(this,`initialized`,!1),o(this,u,{}),o(this,d,0),o(this,f,0),o(this,p,[]),o(this,m,void 0),r(this,`noop`,()=>{}),this.onInitComplete=e.onInitComplete||this.noop,this.onThemeLoaded=e.onThemeLoaded||this.noop,this.onRollResult=e.onRollResult||this.noop,this.onRollComplete=e.onRollComplete||this.noop,this.onDieRemoved=e.onDieRemoved||this.noop,this.initialized=this.initScene(e)}async initScene(e){this.config=e.options,this.onInitComplete()}resize(){}loadTheme(){return Promise.resolve()}updateConfig(e){Object.assign(this.config,e)}addNonDie(e){console.log(`die`,e),clearTimeout(a(this,m));let{id:t,value:n,...r}=e,i={id:t,value:n,config:r};a(this,u)[t]=i,a(this,p).push(setTimeout(()=>{this.handleAsleep(i)},c(this,d)._++*this.config.delay)),s(this,m,setTimeout(()=>{this.onRollComplete()},500))}add(e){console.log(`add die`),this.addNonDie(e)}remove(e){console.log(`remove die`);let t=a(this,u)[e.id];t.hasOwnProperty(`d10Instance`)&&(delete a(this,u)[t.d10Instance.id],c(this,f)._--),delete a(this,u)[e.id],c(this,f)._--,this.onDieRemoved(e.rollId)}clear(){!Object.keys(a(this,u)).length&&!a(this,f)||(a(this,p).forEach(e=>clearTimeout(e)),Object.values(a(this,u)).forEach(e=>{e.mesh&&e.mesh.dispose()}),s(this,u,{}),s(this,d,0),s(this,f,0))}async handleAsleep(t){var n,r;if(t.asleep=!0,await e.getRollResult(t),t.d10Instance||t.dieParent){if((n=t?.d10Instance)!=null&&n.asleep||(r=t?.dieParent)!=null&&r.asleep){let e=t.config.sides===100?t:t.dieParent,n=t.config.sides===10?t:t.d10Instance;n.value===0&&e.value===0?e.value=100:e.value+=n.value,this.onRollResult({rollId:e.config.rollId,value:e.value})}}else t.config.sides===10&&t.value===0&&(t.value=10),this.onRollResult({rollId:t.config.rollId,value:t.value});c(this,f)._++}};l=new WeakMap,u=new WeakMap,d=new WeakMap,f=new WeakMap,p=new WeakMap,m=new WeakMap;export{h as default};